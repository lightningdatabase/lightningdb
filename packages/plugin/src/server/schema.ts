import { Model, Table } from "../modelParser"
import { fieldToZod, filterIdFields } from "../shared"

const dataModelWhereInput = (table: Table): string =>
  `where: z
                  .object({
                    ${table.fields
                      .filter(field => !field.relation)
                      .map(field => fieldToZod(field, { optional: true }))
                      .join("\n                    ")}
                  })
                  .optional(),`

const dataModelWhereUnique = (table: Table): string => {
  const idFields = table.fields.filter(filterIdFields)

  return `where: z
                  .object({
                    ${idFields
                      .map(field => fieldToZod(field, { optional: true }))
                      .join("\n                    ")}
                  })
                  .refine(
                    data => ${idFields
                      .map(field => `data.${field.name} !== undefined`)
                      .join(" || ")},
                    {
                      message: "${idFields
                        .map(field => field.name)
                        .join(" or ")} must be provided",
                    },
                  ),`
}

const dataModelCreateData = (
  table: Table,
  type?: "create",
): string => `${type ?? "data"}: z.object({
                  ${table.fields
                    .filter(field => !field.relation)
                    .map(field =>
                      fieldToZod(field, { optional: field.default }),
                    )
                    .join("\n                  ")}
                }),`

const dataModelCreateManyData = (table: Table): string => `data: z.array(
                  z.object({
                    ${table.fields
                      .filter(field => !field.relation)
                      .map(field =>
                        fieldToZod(field, { optional: field.default }),
                      )
                      .join("\n                    ")}
                  }),
                ),`

const dataModelUpdateData = (
  table: Table,
  type?: "update",
): string => `${type ?? "data"}: z.object({
                  ${table.fields
                    .filter(field => !field.relation)
                    .map(field => fieldToZod(field, { optional: true }))
                    .join("\n                  ")}
                }),`

export const generateSchema = (dataModel: Model): string => {
  const schema = generateApiLightningSchema(dataModel.tables)

  // Write api schema file
  const apiSchema = `////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                        //
// This file is automatically generated by LightningDB Plugin and should not be manually updated. //
////////////////////////////////////////////////////////////////////////////////////////////////////

import { z } from "zod"
import {
  BoolFilter,
  DateTimeFilter,
  IntFilter,
  IntNullableFilter,
  SortOrder,
  StringFilter,
  StringNullableFilter,
} from "@lightningdb/server/types"
import type { Includes } from "@lightningdb/server/types"

${schema}

export const tablesMap: Record<string, string> = {
  ${Object.entries(dataModel.tableMap)
    .map(([key, value]) => `${key}: "${value}",`)
    .join("\n  ")}
}

export const includesMap: Includes = {
  ${dataModel.tables
    .map(
      table => `${table.pluralName}: {
    ${table.fields
      .filter(field => field.relation)
      .map(
        field => `${field.name}: {
      type: "${field.relation?.type}",
      model: "${field.relation?.relationTable.pluralName}",
      field: "${field.relation?.fields?.[0]}",
    },`,
      )
      .join("\n    ")}
  },`,
    )
    .join("\n  ")}
}
`

  return apiSchema
}

const generateApiLightningSchema = (tables: Table[]): string =>
  `${tables
    .map(
      table => `const ${table.name}ListRelationFilter: z.ZodType<
  | {
      every?: z.infer<typeof ${table.name}WhereInput>
      some?: z.infer<typeof ${table.name}WhereInput>
      none?: z.infer<typeof ${table.name}WhereInput>
    }
  | undefined
> = z.lazy(() => z
  .object({
    every: ${table.name}WhereInput,
    some: ${table.name}WhereInput,
    none: ${table.name}WhereInput,
  })
  .optional())`,
    )
    .join("\n\n")}

${tables
  .map(
    table => `const ${table.name}WhereInput = z
  .object({
    ${table.fields
      .filter(field => !field.relation) // Filter out relationship fields
      .map(field => fieldToZod(field, { optional: true, filters: true }))
      .join("\n    ")}
    ${table.fields
      .filter(field => field.relation && field.array)
      .map(
        field =>
          `${field.name}: ${field.relation?.relationTable.name}ListRelationFilter,`,
      )
      .join("\n    ")}
    ${table.fields
      .filter(field => field.relation && !field.array)
      .map(
        field =>
          `${field.name}: ${field.relation?.relationTable.name}WhereInput${
            field.optional ? ".nullable()" : ""
          },`,
      )
      .join("\n    ")}
  })
  .optional()`,
  )
  .join("\n\n")}

${tables
  .map(
    table => `const ${table.name}OrderBy = z
  .object({
    ${table.fields
      .filter(field => !field.relation)
      .map(field => `${field.name}: SortOrder,`)
      .join("\n    ")}
  })
  .optional()`,
  )
  .join("\n\n")}

${tables
  .map(
    table => `const ${table.name}Include: z.ZodType<
  | {
      ${table.fields
        .filter(field => field.relation)
        .map(
          field => `${field.name}?:
        | boolean
        | {
            where?: z.infer<typeof ${
              field.relation?.relationTable.name
            }WhereInput>
            include?: z.infer<typeof ${
              field.relation?.relationTable.name
            }Include>${
              field.array
                ? "\n            take?: number\n            skip?: number"
                : ""
            }
          }`,
        )
        .join("\n      ")}
    }
  | undefined
> = z.lazy(() =>
  z
    .object({
    ${table.fields
      .filter(field => field.relation)
      .map(
        field => `  ${field.name}: z
        .union([
          z.boolean(),
          z.object({
            where: ${field.relation?.relationTable.name}WhereInput,
            include: ${field.relation?.relationTable.name}Include,${
              field.array
                ? `\n            take: z.number().optional(),\n            skip: z.number().optional(),\n            orderBy: ${field.relation?.relationTable.name}OrderBy,`
                : ""
            }
          }),
        ])
        .optional(),`,
      )
      .join("\n    ")}
    })
    .optional(),
)`,
  )
  .join("\n\n")}

${tables
  .map(
    table => `const ${table.pluralName}Query = z.object({
  table: z.literal("${table.pluralName}"),
  where: ${table.name}WhereInput,
  include: ${table.name}Include,
  take: z.number().optional(),
  skip: z.number().optional(),
  orderBy: ${table.name}OrderBy,
})`,
  )
  .join("\n\n")}

export const lightningSchema = z.object({
  queries: z.array(z.union([${tables.map(table => `${table.pluralName}Query`).join(", ")}])).optional(),
  mutations: z
    .array(
      z.object({
        ${tables
          .map(
            model => `${model.pluralName}: z
          .object({
            create: z
              .object({
                ${dataModelCreateData(model)}
              })
              .optional(),
            createMany: z
              .object({
                ${dataModelCreateManyData(model)}
              })
              .optional(),
            update: z
              .object({
                ${dataModelWhereUnique(model)}
                ${dataModelUpdateData(model)}
              })
              .optional(),
            updateMany: z
              .object({
                ${dataModelWhereInput(model)}
                ${dataModelUpdateData(model)}
              })
              .optional(),
            upsert: z
              .object({
                ${dataModelWhereUnique(model)}
                ${dataModelCreateData(model, "create")}
                ${dataModelUpdateData(model, "update")}
              })
              .optional(),
            delete: z
              .object({
                ${dataModelWhereUnique(model)}
              })
              .optional(),
            deleteMany: z
              .object({
                ${dataModelWhereInput(model)}
              })
              .optional(),
          })
          .optional(),`,
          )
          .join("\n        ")}
      }),
    )
    .optional(),
  queryId: z.number().optional(),
})`
